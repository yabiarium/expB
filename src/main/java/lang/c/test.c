void funcA();
void funcB(int []);
func void funcA(){
    int a[3];
    a[0] = 1; 
    a[1] = 2;
    a[2] = 3;
    call funcB(&a);
    output a[0]+a[1]+a[2]; //funcBの処理で書き換わっているのが正常のはず…
}
func void funcB(int a[]){ //配列型の引数は関数内で配列の先頭アドレスを指すポインタのみ局所変数用の場所にコピーする(扱いは配列型のまま)
    output a[0]+a[1]+a[2]; //実引数をローカル変数として受け取って初期化できているか（ローカルの配列変数の割当番地を、受け取ったアドレスで初期化すれば良い）
    a[2] = a[2]*3; //書き換え
    output a[2];
}


//残りの作業
//・配列型の実引数をどうするか
//・フレームポインタの位置をどうするか→配列の要素数は考えなくてよい(先頭アドレスを指すポインタ型なので)。よって実引数の数分だけずらす
//・どうずらす？→（現予想）argListで最後の実引数からスタックに積んでいく、数をカウントしておいて、FPをその数だけずらす、関数内からのアクセスはFPから負の相対位置を用いる

/*
例えば、int a[3]という配列の場合、aは&a[0]（つまり、a[0]のアドレス）と同じ意味になります。
関数funcBの引数int b[]は、実際にはint *b（整数型へのポインタ）として解釈されます。
*/
